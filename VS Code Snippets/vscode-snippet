{
	"first line": {
		"prefix": "Test",
		"body": [
		  "for _ in range(int(input())):"
		],
		"description": "first line"
	  },
	  "taking a line of inputs": {
		"prefix": "listInput",
		"body": [
		  "$1 = list(map(int,input().split()))"
		],
		"description": "taking a line of inputs"
	  },
	  "taking one input": {
		"prefix": "Input",
		"body": [
		  "$1=int(input())"
		],
		"description": "taking one input"
	  },
	  "taking two inputs": {
		"prefix": "twoInput",
		"body": [
		  "$1,$2=map(int,input().split())"
		],
		"description": "taking two inputs"
	  },
	  "taking three inputs": {
		"prefix": "threeInput",
		"body": [
		  "$1,$2,$3=map(int,input().split())"
		],
		"description": "taking three inputs"
	  },
	  "taking four inputs": {
		"prefix": "fourInput",
		"body": [
		  "$1,$2,$3,$4=map(int,input().split())"
		],
		"description": "taking four inputs"
	  },
	  "binary search template": {
		"prefix": "binSearch",
		"body": [
		  "def binary_search(array):",
		  "    def condition(value):",
		  "        pass",
		  "",
		  "    left, right = 0, len(array)",
		  "    while left < right:",
		  "        mid = left + (right - left) // 2",
		  "        if condition(mid):",
		  "            right = mid",
		  "        else:",
		  "            left = mid + 1",
		  "    return left"
		],
		"description": "binary search template"
	  },
	  "ternary search": {
		"prefix": "ternary",
		"body": [
		  "def ternarySearch(arr,x,l,r):",
		  "    while(r>=l):",
		  "        mid1=l+(r-l)//3",
		  "        mid2=r-(r-l)//3",
		  "        if(x==arr[mid1]):",
		  "            return mid1",
		  "        elif(x==arr[mid2]):",
		  "            return mid2",
		  "        if(x<arr[mid1]):",
		  "            r=mid1-1",
		  "        elif(x>arr[mid2]):",
		  "            l=mid2+1",
		  "        else:",
		  "            l=mid1+1",
		  "            r=mid2-1",
		  "    return -1"
		],
		"description": "ternary search"
	  },
	  "Seive": {
		"prefix": "primeSeive",
		"body": [
		  "def SieveOfEratosthenes(n): ",
		  "    prime = [True for i in range(n + 1)] ",
		  "    p = 2",
		  "    while (p * p <= n): ",
		  "        if (prime[p] == True): ",
		  "            for i in range(p * 2, n + 1, p): ",
		  "                prime[i] = False",
		  "        p += 1",
		  "    prime[0]= False",
		  "    prime[1]= False ",
		  "    for p in range(n + 1): ",
		  "        if prime[p]: ",
		  "            print(p)"
		],
		"description": "Seive"
	  },
	  "prime number check": {
		"prefix": "isPrime",
		"body": [
		  "def isPrime(n):",
		  "    if n==1:",
		  "        return False",
		  "    i=2",
		  "    while(i*i<=n):",
		  "        if n%i==0:",
		  "            return False",
		  "        i+=1",
		  "    return True"
		],
		"description": "prime number check"
	  },
	  "template": {
		"prefix": "template",
		"body": [
		  "from __future__ import division, print_function",
		  "",
		  "import os",
		  "import sys",
		  "from io import BytesIO, IOBase",
		  "",
		  "def main():",
		  "    pass",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "if sys.version_info[0] < 3:",
		  "    from __builtin__ import xrange as range",
		  "    from future_builtins import ascii, filter, hex, map, oct, zip",
		  "",
		  "# region fastio",
		  "# Credits",
		  "# # template credits to cheran-senthil's github Repo",
		  "",
		  "BUFSIZE = 8192",
		  "",
		  "",
		  "class FastIO(IOBase):",
		  "    newlines = 0",
		  "",
		  "    def __init__(self, file):",
		  "        self._fd = file.fileno()",
		  "        self.buffer = BytesIO()",
		  "        self.writable = \"x\" in file.mode or \"r\" not in file.mode",
		  "        self.write = self.buffer.write if self.writable else None",
		  "",
		  "    def read(self):",
		  "        while True:",
		  "            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
		  "            if not b:",
		  "                break",
		  "            ptr = self.buffer.tell()",
		  "            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
		  "        self.newlines = 0",
		  "        return self.buffer.read()",
		  "",
		  "    def readline(self):",
		  "        while self.newlines == 0:",
		  "            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
		  "            self.newlines = b.count(b\"\\n\") + (not b)",
		  "            ptr = self.buffer.tell()",
		  "            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
		  "        self.newlines -= 1",
		  "        return self.buffer.readline()",
		  "",
		  "    def flush(self):",
		  "        if self.writable:",
		  "            os.write(self._fd, self.buffer.getvalue())",
		  "            self.buffer.truncate(0), self.buffer.seek(0)",
		  "",
		  "",
		  "class IOWrapper(IOBase):",
		  "    def __init__(self, file):",
		  "        self.buffer = FastIO(file)",
		  "        self.flush = self.buffer.flush",
		  "        self.writable = self.buffer.writable",
		  "        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
		  "        self.read = lambda: self.buffer.read().decode(\"ascii\")",
		  "        self.readline = lambda: self.buffer.readline().decode(\"ascii\")",
		  "",
		  "",
		  "def print(*args, **kwargs):",
		  "    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"",
		  "    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)",
		  "    at_start = True",
		  "    for x in args:",
		  "        if not at_start:",
		  "            file.write(sep)",
		  "        file.write(str(x))",
		  "        at_start = False",
		  "    file.write(kwargs.pop(\"end\", \"\\n\"))",
		  "    if kwargs.pop(\"flush\", False):",
		  "        file.flush()",
		  "",
		  "",
		  "if sys.version_info[0] < 3:",
		  "    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)",
		  "else:",
		  "    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
		  "",
		  "input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")",
		  "",
		  "# endregion",
		  "",
		  "",
		  "if __name__ == \"__main__\":",
		  "    main()"
		],
		"description": "template"
	  },
	  "fenwick tree class": {
		"prefix": "fenwick",
		"body": [
		  "class BIT:",
		  "    def __init__(self,list):",
		  "        self.array = [0]+list",
		  "        for idx in range(1,len(self.array)):",
		  "            idx2 = idx+(idx & -idx)",
		  "            if idx2<len(self.array):",
		  "                self.array[idx2] += self.array[idx]",
		  "    ",
		  "    def prefix_query(self,idx):",
		  "        idx+=1",
		  "        result = 0",
		  "        while idx:",
		  "            result += self.array[idx]",
		  "            idx -= idx & -idx",
		  "        return result",
		  "    ",
		  "    def range_query(self,from_idx,to_idx):",
		  "        return self.prefix_query(to_idx) - self.prefix_query(from_idx-1)",
		  "    ",
		  "    def update(self,idx,add):",
		  "        idx+=1",
		  "        while idx<len(self.array):",
		  "            self.array[idx]+=add",
		  "            idx+= idx & -idx"
		],
		"description": "fenwick tree class"
	  },
	  "graphclass": {
		"prefix": "graphclass",
		"body": [
		  "import sys",
		  "from collections import deque as queue",
		  "sys.setrecursionlimit(10 ** 6)",
		  "class Graph(object):",
		  "",
		  "    def __init__(self):",
		  "        self.neighbours = {}",
		  "    ",
		  "    def __repr__(self):",
		  "        s = ''",
		  "        for i in self.neighbours:",
		  "            s += str(i)+': '+' '.join(map(str,self.neighbours[i])) + '\\n'",
		  "        return s",
		  "    ",
		  "    def add_node(self, node):",
		  "        self.neighbours[node] = set()",
		  "    ",
		  "    def add_edge(self, edge):",
		  "        u, v = edge",
		  "        self.neighbours[u].add(v)",
		  "        self.neighbours[v].add(u)",
		  "    ",
		  "    def dfs(self, node):",
		  "        visited[node] = 1",
		  "        for child in self.neighbours[node]:",
		  "            if visited[child] == 0:",
		  "                self.dfs(child)",
		  "    ",
		  "    def bfs(self, node):",
		  "        q = queue()",
		  "        visited[node] = 1",
		  "        q.append(node)",
		  "        while q:",
		  "            cur = q.popleft()",
		  "            for child in self.neighbours[cur]:",
		  "                if visited[child] == 0:",
		  "                    q.append(child)",
		  "                    visited[child] = 1",
		  "",
		  "g = Graph()",
		  "n, e = map(int, input().split())",
		  "for i in range(n):",
		  "    g.add_node(i+1)",
		  "for i in range(e):",
		  "    x, y = map(int, input().split())",
		  "    g.add_edge((x, y))",
		  "visited = [0] * (n + 1)"
		],
		"description": "graphclass"
	  },
	  "bootstrap": {
		"prefix": "bootstrap",
		"body": [
		  "from types import GeneratorType",
		  "def bootstrap(f, stack=[]):",
		  "    def wrappedfunc(*args, **kwargs):",
		  "        if stack:",
		  "            return f(*args, **kwargs)",
		  "        else:",
		  "            to = f(*args, **kwargs)",
		  "            while True:",
		  "                if type(to) is GeneratorType:",
		  "                    stack.append(to)",
		  "                    to = next(to)",
		  "                else:",
		  "                    stack.pop()",
		  "                    if not stack:",
		  "                        break",
		  "                    to = stack[-1].send(to)",
		  "            return to",
		  "    return wrappedfunc"
		],
		"description": "bootstrap"
	  },
	  "timer": {
		"prefix": "timer",
		"body": [
		  "import time",
		  "def timer(f):",
		  "    def wrapper(*args, **kwargs):",
		  "        start = time.time()",
		  "        rv = f(*args, **kwargs)",
		  "        total = time.time() - start",
		  "        print(\"Time taken: {}ms\".format(total*1000))",
		  "        return rv",
		  "    return wrapper"
		],
		"description": "timer"
	  },
	  "binPow": {
		"prefix": "binPow",
		"body": [
		  "def binPow(n, r):",
		  "    c = 1",
		  "    while r > 0:",
		  "        if r & 1:",
		  "            r -= 1",
		  "            c *= n",
		  "        r = r // 2",
		  "        n = n ** 2",
		  "    return c"
		],
		"description": "binPow"
	  },
	  "ceil": {
		"prefix": "ceil",
		"body": [
		  "def ceil(a, b):",
		  "    return (a + b - 1) // b"
		],
		"description": "ceil"
	  },
	  "skeleton": {
		"prefix": "skeleton",
		"body": [
		  "#include<bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "",
		  "",
		  "int i = 0,j = 0,k = 0;",
		  "#define INT             long long",
		  "#define mod             1000000007",
		  "#define inf             (int)1e18",
		  "#define endl            \"\\n\"",
		  "#define FOR(a, b)       for (int i = a; i < b;i++)",
		  "#define inpArr(vec)          for(auto &it:vec) cin>>it",
		  "#define outArr(vec)          for(auto &it:vec) cout<<it<<\" \";cout<<endl;",
		  "#define read(n) 			INT n;cin >> n;",
		  "#define readTwo(x, y) 		INT x, y;cin>>x>>y;",
		  "#define readThree(x, y, z) 	INT x, y, z;cin>>x>>y>>z;",
		  "#define readFour(x, y, z,a) INT x, y, z, a;cin>>x>>y>>z>>a;",
		  "",
		  "",
		  "void solve(){",
		  "	",
		  "}",
		  "",
		  "",
		  "",
		  "",
		  "int main(){",
		  "ios_base::sync_with_stdio(0);cin.tie(NULL);",
		  "",
		  "int tt=1;",
		  "cin >> tt;",
		  "while(tt--){",
		  "	solve();",
		  "}",
		  "",
		  "return 0;",
		  "	",
		  "}"
		],
		"description": "skeleton"
	  },
	  "debugCpp": {
		"prefix": "debug",
		"body": [
		  "void __print(int x) {cerr << x;}",
		  "void __print(long x) {cerr << x;}",
		  "void __print(long long x) {cerr << x;}",
		  "void __print(unsigned x) {cerr << x;}",
		  "void __print(unsigned long x) {cerr << x;}",
		  "void __print(unsigned long long x) {cerr << x;}",
		  "void __print(float x) {cerr << x;}",
		  "void __print(double x) {cerr << x;}",
		  "void __print(long double x) {cerr << x;}",
		  "void __print(char x) {cerr << '\\'' << x << '\\'';}",
		  "void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}",
		  "void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}",
		  "void __print(bool x) {cerr << (x ? \"true\" : \"false\");}",
		  "",
		  "template<typename T, typename V>",
		  "void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}",
		  "template<typename T>",
		  "void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}",
		  "void _print() {cerr << \"]\\n\";}",
		  "template <typename T, typename... V>",
		  "void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",
		  "#ifndef ONLINE_JUDGE",
		  "#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)",
		  "#else",
		  "#define debug(x...)",
		  "#endif"
		],
		"description": "debugCpp"
	  }
}
